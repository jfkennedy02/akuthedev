<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Akuthedev City 3D Portfolio</title>
<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden; height: 100%;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #87ceeb;
  }
  #overlay {
    position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
    background: rgba(0,0,0,0.7);
    display: flex; flex-direction: column; justify-content: center; align-items: center;
    color: white; font-size: 1.5rem; text-align: center;
    z-index: 10;
  }
  #startBtn {
    margin-top: 20px;
    background: #28a745; border: none; padding: 12px 24px;
    font-size: 1.25rem; border-radius: 8px;
    cursor: pointer;
    color: white;
    transition: background 0.3s ease;
  }
  #startBtn:hover {
    background: #218838;
  }
  #infoPanel {
    position: fixed; bottom: 10px; left: 10px;
    background: rgba(255 255 255 / 0.9);
    padding: 10px 20px; border-radius: 8px;
    max-width: 320px; font-size: 1rem;
    display: none;
    z-index: 9;
  }
  canvas {
    display: block;
  }
</style>
</head>
<body>
<div id="overlay">
  <div>
    <div style="font-size: 2rem; margin-bottom: 10px;">üõª Welcome to Akuthedev City üö¶</div>
    <div>Where Every Street Leads to a Story</div>
    <div style="margin-top: 15px; font-size: 1rem;">
      Controls:<br />
      W / ‚Üë = Drive Forward, S / ‚Üì = Reverse, A / ‚Üê = Left, D / ‚Üí = Right, Enter = Interact
    </div>
    <button id="startBtn">üöó Start Driving</button>
  </div>
</div>
<div id="infoPanel"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>

<script>
(() => {
  // Basic setup
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  document.body.appendChild(renderer.domElement);

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // Lighting
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(ambientLight);

  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
  directionalLight.position.set(50, 100, 50);
  directionalLight.castShadow = true;
  directionalLight.shadow.mapSize.width = 2048;
  directionalLight.shadow.mapSize.height = 2048;
  scene.add(directionalLight);

  // Ground
  const groundGeo = new THREE.PlaneGeometry(500, 500);
  const groundMat = new THREE.MeshStandardMaterial({color: 0x228822});
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.receiveShadow = true;
  scene.add(ground);

  // Roads - black planes
  function createRoad(x, z, width, height) {
    const geo = new THREE.PlaneGeometry(width, height);
    const mat = new THREE.MeshStandardMaterial({color: 0x222222});
    const mesh = new THREE.Mesh(geo, mat);
    mesh.rotation.x = -Math.PI/2;
    mesh.position.set(x, 0.01, z);
    mesh.receiveShadow = true;
    scene.add(mesh);
  }
  createRoad(0, 0, 200, 20);
  createRoad(0, 0, 20, 200);

  // Sidewalks - light gray planes
  function createSidewalk(x, z, w, h) {
    const geo = new THREE.PlaneGeometry(w, h);
    const mat = new THREE.MeshStandardMaterial({color: 0xCCCCCC});
    const mesh = new THREE.Mesh(geo, mat);
    mesh.rotation.x = -Math.PI/2;
    mesh.position.set(x, 0.02, z);
    scene.add(mesh);
  }
  createSidewalk(0, -15, 200, 10);
  createSidewalk(0, 15, 200, 10);
  createSidewalk(-15, 0, 10, 200);
  createSidewalk(15, 0, 10, 200);

  // Fountain as real 3D mesh - Cylinder + animated water sphere
  const plazaX = -60, plazaZ = 60;
  const fountainBaseGeo = new THREE.CylinderGeometry(5, 5, 1, 32);
  const fountainBaseMat = new THREE.MeshStandardMaterial({color: 0x3399ff, emissive: 0x2266ff, emissiveIntensity: 0.4});
  const fountainBase = new THREE.Mesh(fountainBaseGeo, fountainBaseMat);
  fountainBase.position.set(plazaX, 0.5, plazaZ);
  fountainBase.castShadow = true;
  fountainBase.receiveShadow = true;
  scene.add(fountainBase);

  const waterGeo = new THREE.SphereGeometry(1.5, 16, 16);
  const waterMat = new THREE.MeshStandardMaterial({color: 0x3399ff, transparent: true, opacity: 0.7});
  const water = new THREE.Mesh(waterGeo, waterMat);
  water.position.set(plazaX, 1.5, plazaZ);
  scene.add(water);

  gsap.to(water.position, {y: 2.5, duration: 2, repeat: -1, yoyo: true, ease: "sine.inOut"});

  // Bench as real 3D box
  function createBench(x, z) {
    const benchGeo = new THREE.BoxGeometry(6, 0.5, 2);
    const benchMat = new THREE.MeshStandardMaterial({color: 0x8B4513});
    const bench = new THREE.Mesh(benchGeo, benchMat);
    bench.position.set(x, 0.25, z);
    bench.castShadow = true;
    bench.receiveShadow = true;
    scene.add(bench);
    return bench;
  }
  const bench = createBench(plazaX + 10, plazaZ + 5);

  // Billboard 3D frame with texture
  function createBillboard(x, z, imgURL) {
    // Frame
    const frameGeo = new THREE.BoxGeometry(13, 7, 0.5);
    const frameMat = new THREE.MeshStandardMaterial({color: 0x333333});
    const frame = new THREE.Mesh(frameGeo, frameMat);
    frame.position.set(x, 6, z);
    frame.castShadow = true;
    frame.receiveShadow = true;

    // Screen
    const screenGeo = new THREE.PlaneGeometry(12, 6.5);
    const texture = new THREE.TextureLoader().load(imgURL);
    const screenMat = new THREE.MeshStandardMaterial({map: texture});
    const screen = new THREE.Mesh(screenGeo, screenMat);
    screen.position.set(0, 0, 0.26);
    frame.add(screen);

    scene.add(frame);
    return frame;
  }

  const billboardImages = [
    "https://via.placeholder.com/512x256.png?text=Project+1",
    "https://via.placeholder.com/512x256.png?text=Project+2",
    "https://via.placeholder.com/512x256.png?text=Project+3",
  ];
  const billboardPositions = [
    [40, -40],
    [60, -70],
    [80, -40],
  ];
  const billboards = [];
  for(let i=0; i < billboardPositions.length; i++) {
    billboards.push(createBillboard(billboardPositions[i][0], billboardPositions[i][1], billboardImages[i]));
  }

  // Contact Building (GLTF model)
  // We'll load an office building GLTF from Khronos sample to keep it 3D & realistic
  const loader = new THREE.GLTFLoader();

  let contactBuilding = null;
  loader.load(
    'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Building/glTF/Building.gltf',
    (gltf) => {
      contactBuilding = gltf.scene;
      contactBuilding.scale.set(10, 10, 10);
      contactBuilding.position.set(60, 0, 60);
      contactBuilding.traverse((child) => {
        if(child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
        }
      });
      scene.add(contactBuilding);
    },
    undefined,
    err => console.error('Contact building load error:', err)
  );

  // Trees (GLTF model) - multiple trees scattered
  let treeModel = null;
  loader.load(
    'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Tree/glTF/Tree.gltf',
    (gltf) => {
      treeModel = gltf.scene;
      treeModel.scale.set(0.7, 0.7, 0.7);
      treeModel.traverse((child) => {
        if(child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
        }
      });

      const treePositions = [
        [-40, 50],
        [-50, 55],
        [-45, 60],
        [-30, 40],
        [10, 30],
        [55, -20],
        [70, 20]
      ];

      treePositions.forEach(pos => {
        const tree = treeModel.clone();
        tree.position.set(pos[0], 0, pos[1]);
        scene.add(tree);
      });
    },
    undefined,
    err => console.error('Tree load error:', err)
  );

  // Car model
  let car = null;
  loader.load(
    'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/CesiumMilkTruck/glTF/CesiumMilkTruck.gltf',
    (gltf) => {
      car = gltf.scene;
      car.scale.set(0.1, 0.1, 0.1);
      car.position.set(0, 0, 0);
      car.rotation.y = Math.PI; // face forward
      car.traverse((child) => {
        if(child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
        }
      });
      scene.add(car);
    },
    undefined,
    err => console.error('Car load error:', err)
  );

  // Simple pedestrians - animated colored boxes walking in place near plaza
  const pedestrians = [];
  const pedestrianColors = [0xff4444, 0x44ff44, 0x4444ff];
  for(let i=0; i<5; i++) {
    const pedGeo = new THREE.BoxGeometry(1, 2, 1);
    const pedMat = new THREE.MeshStandardMaterial({color: pedestrianColors[i % pedestrianColors.length]});
    const ped = new THREE.Mesh(pedGeo, pedMat);
    ped.position.set(plazaX + 10 + i*2, 1, plazaZ - 10);
    ped.castShadow = true;
    ped.receiveShadow = true;
    scene.add(ped);
    pedestrians.push(ped);
  }

  // Animate pedestrians simple sway
  function animatePedestrians(time) {
    pedestrians.forEach((ped, idx) => {
      ped.rotation.y = Math.sin(time * 2 + idx) * 0.5;
    });
  }

  // Camera follow setup
  const cameraTargetOffset = new THREE.Vector3(0, 5, -15);

  // Controls
  const keys = {};
  window.addEventListener('keydown', e => {
    keys[e.key.toLowerCase()] = true;
  });
  window.addEventListener('keyup', e => {
    keys[e.key.toLowerCase()] = false;
  });

  // Interaction UI
  const infoPanel = document.getElementById('infoPanel');

  function checkDistance(obj, maxDist=5) {
    if(!car || !obj) return false;
    const posA = new THREE.Vector3();
    obj.getWorldPosition(posA);
    const dist = car.position.distanceTo(posA);
    return dist < maxDist;
  }

  function interact() {
    if(!car) return;

    if(checkDistance(bench, 3)) {
      showInfo("You sit on the bench. Akuthedev is a passionate meme token web developer creating fun digital experiences.");
      return;
    }
    if(checkDistance(fountainBase, 5)) {
      showInfo("This plaza is where Akuthedev's journey began, symbolized by this fountain of creativity.");
      return;
    }
    for(let i=0; i < billboards.length; i++) {
      if(checkDistance(billboards[i], 5)) {
        const sites = [
          "https://example.com/project1",
          "https://example.com/project2",
          "https://example.com/project3",
        ];
        const site = sites[Math.floor(Math.random()*sites.length)];
        window.open(site, "_blank");
        return;
      }
    }
    if(contactBuilding && checkDistance(contactBuilding, 15)) {
      showContactForm();
      return;
    }
    showInfo("No interactable object nearby.");
  }

  let infoTimeout;
  function showInfo(text) {
    infoPanel.style.display = "block";
    infoPanel.innerHTML = text;
    clearTimeout(infoTimeout);
    infoTimeout = setTimeout(() => {
      infoPanel.style.display = "none";
    }, 8000);
  }

  // Contact form popup
  let contactFormDiv = null;
  function showContactForm() {
    if(contactFormDiv) return;
    contactFormDiv = document.createElement("div");
    contactFormDiv.style = `
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: white; padding: 20px; border-radius: 12px; max-width: 320px;
      box-shadow: 0 0 10px rgba(0,0,0,0.5); z-index: 15;
    `;
    contactFormDiv.innerHTML = `
      <h2>Contact Akuthedev</h2>
      <form id="contactForm">
        <label>Name:<br><input type="text" name="name" required></label><br><br>
        <label>Email:<br><input type="email" name="email" required></label><br><br>
        <label>Message:<br><textarea name="message" rows="4" required></textarea></label><br><br>
        <button type="submit">Send</button>
        <button type="button" id="cancelBtn">Cancel</button>
      </form>
      <div id="formResult" style="margin-top: 10px; color: green;"></div>
    `;
    document.body.appendChild(contactFormDiv);

    document.getElementById("cancelBtn").onclick = () => {
      if(contactFormDiv) {
        document.body.removeChild(contactFormDiv);
        contactFormDiv = null;
      }
    };
    document.getElementById("contactForm").onsubmit = e => {
      e.preventDefault();
      document.getElementById("formResult").textContent = "Thank you! Message sent.";
      setTimeout(() => {
        if(contactFormDiv) {
          document.body.removeChild(contactFormDiv);
          contactFormDiv = null;
        }
      }, 2500);
    };
  }

  // Driving variables
  let speed = 0;
  const maxSpeed = 0.5;
  const acceleration = 0.02;
  const turnSpeed = 0.04;

  // Day/night cycle
  let clock = new THREE.Clock();
  let time = 0;

  // Ambient sound (birds)
  const audioListener = new THREE.AudioListener();
  camera.add(audioListener);
  const audioLoader = new THREE.AudioLoader();
  const ambientSound = new THREE.Audio(audioListener);
  audioLoader.load('https://cdn.pixabay.com/download/audio/2022/03/01/audio_8fcb8e3772.mp3?filename=birds-and-wind-ambient-19657.mp3', buffer => {
    ambientSound.setBuffer(buffer);
    ambientSound.setLoop(true);
    ambientSound.setVolume(0.15);
    ambientSound.play();
  });

  // Main animation loop
  function animate() {
    requestAnimationFrame(animate);

    const delta = clock.getDelta();
    time += delta;

    // Animate pedestrians
    animatePedestrians(time);

    // Animate day/night sky color
    const dayFactor = (Math.sin(time / 30) + 1) / 2; // 0..1 over 60s cycle
    const dayColor = new THREE.Color(0x87ceeb);
    const nightColor = new THREE.Color(0x000022);
    const skyColor = dayColor.clone().lerp(nightColor, 1 - dayFactor);
    renderer.setClearColor(skyColor);

    // Adjust directional light intensity & color by time
    directionalLight.intensity = 0.2 + 0.8 * dayFactor;
    directionalLight.color.setHSL(0.1, 0.6, 0.5 + 0.5 * dayFactor);

    // Car controls & movement
    if(car) {
      // Acceleration / braking
      if(keys['w'] || keys['arrowup']) {
        speed = Math.min(speed + acceleration, maxSpeed);
      } else if(keys['s'] || keys['arrowdown']) {
        speed = Math.max(speed - acceleration, -maxSpeed/2);
      } else {
        // friction slows down
        speed *= 0.95;
      }

      // Turning only if speed is significant
      if(Math.abs(speed) > 0.01) {
        if(keys['a'] || keys['arrowleft']) {
          car.rotation.y += turnSpeed * Math.sign(speed);
        }
        if(keys['d'] || keys['arrowright']) {
          car.rotation.y -= turnSpeed * Math.sign(speed);
        }
      }

      // Move car
      const forward = new THREE.Vector3(0, 0, 1);
      forward.applyEuler(car.rotation);
      car.position.add(forward.multiplyScalar(speed));

      // Keep car on ground
      car.position.y = 0;

      // Camera follows car
      const desiredCamPos = car.position.clone().add(cameraTargetOffset.clone().applyEuler(car.rotation));
      camera.position.lerp(desiredCamPos, 0.1);
      camera.lookAt(car.position.clone().add(new THREE.Vector3(0, 3, 0)));
    }

    renderer.render(scene, camera);
  }

  animate();

  // Interaction on Enter
  window.addEventListener('keydown', e => {
    if(e.key === 'Enter') {
      interact();
    }
  });

  // Overlay start driving button
  const overlay = document.getElementById('overlay');
  const startBtn = document.getElementById('startBtn');
  startBtn.onclick = () => {
    overlay.style.display = 'none';
    // Place car at starting position
    if(car) {
      car.position.set(0, 0, 0);
      car.rotation.y = Math.PI;
    }
    camera.position.set(0, 5, 15);
  };

})();
</script>
</body>
</html>
